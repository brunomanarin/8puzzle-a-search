<html>

<head>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div id="main">
        <ul id="boardPuzzle">
            <li></li>
            <li></li>
            <li></li>
        </ul>
    </div>
    <div id= "infos">

    </div>
    <script>
        const boardHTML = document.getElementById("boardPuzzle")
        const goalBoardMap = {
            1: [0, 0],
            2: [0, 1],
            3: [0, 2],
            4: [1, 0],
            5: [1, 1],
            6: [1, 2],
            7: [2, 0],
            8: [2, 1],
            0: [2, 2]
        }
        //const board = [[1,2,0], [4,5,3], [7,8,6]]
        const board = [[1, 8, 2],[0, 4, 3],[7, 6, 5]]
        const tree = []
        let gCounter = 0;
        let nextNode = null;


        const expandedNodes = []
        const frontier = []
        const checkIfSolvable = (board) => {
            let invCount = 0;
            board.map((row, rowIndex) =>{
                row.map((num, numIndex) =>{
                    if (board[rowIndex][numIndex] > 0 && board[rowIndex][numIndex] > board[numIndex][rowIndex]){
                        invCount += 1;
                    }
                })
            })
            console.log(invCount)
            return (invCount % 2 == 0);
        }
        const findMovementPossibilities = (spaceIndex) => {
            const pos = spaceIndex[0]
            const row = spaceIndex[1]

            switch (row) {
                case 0:
                    switch (pos) {
                        case 0:
                            return [null, [1, 0], null, [0, 1]]
                        case 1:
                            return [null, [1, 1], [0, 0], [0, 2]]
                        case 2:
                            return [null, [1, 2], [0, 1], null]

                    }
                case 1:
                    switch (pos) {
                        case 0:
                            return [[0, 0], [2, 0], null, [1, 1]]
                        case 1:
                            return [[0, 1], [2, 1], [1, 0], [1, 2]]
                        case 2:
                            return [[0, 2], [2, 2], [1, 1], null]

                    }
                case 2:
                    switch (pos) {
                        case 0:
                            return [[1, 0], null, null, [2, 1]]
                        case 1:
                            return [[1, 1], null, [2, 0], [2, 2]]
                        case 2:
                            return [[1, 2], null, [2, 1], null]
                    }
            }
        }
        const buildTreeBranch = (parentNode, parentNodeInfo) => {
            const emptySpaceIndex = findNodeEmptySpace(parentNode)
            const possibleMovements = findMovementPossibilities(emptySpaceIndex)
            const treeBranchList = possibleMovements.map(possibility => {
                if (possibility) {
                    const treeNode = JSON.parse(JSON.stringify(parentNode));
                    const temp = treeNode[possibility[0]][possibility[1]]
                    treeNode[possibility[0]][possibility[1]] = 0
                    treeNode[emptySpaceIndex[1]][emptySpaceIndex[0]] = temp
                    let hCounter = 0;
                    treeNode.map((row, rowIndex) => {
                        const isAtRightPlace = row.map((num, numIndex) => {
                            const goalCoordinates = goalBoardMap[num]
                            if (goalCoordinates[0] !== rowIndex || goalCoordinates[1] !== numIndex) {
                                return hCounter++
                            }
                        })
                    })

                    if (JSON.stringify(parentNodeInfo.treeNode) !== JSON.stringify(treeNode) && JSON.stringify(parentNode) !== JSON.stringify(treeNode) && JSON.stringify(board) !== JSON.stringify(treeNode)) {
                        return { treeNode, hValue: hCounter, gValue: gCounter, parent: parentNodeInfo }
                    }
                }
            })
            return treeBranchList.filter(val => val !== undefined && val !== null)
        }
        const fillBoard = (board) => {
            const numbersList = [1, 2, 3, 4, 5, 6, 7, 8, 0]
            for (let i = 0; i < board.length; i++) {
                while (board[i].length < 3) {
                    const randomNumber = numbersList[Math.floor(Math.random() * 9)]
                    const alreadyHasNumberInRows = board.map(row => {
                        return row.includes(randomNumber)
                    })
                    if (!alreadyHasNumberInRows[0] && !alreadyHasNumberInRows[1] && !alreadyHasNumberInRows[2]) {
                        board[i].push(randomNumber)
                    }
                }
            }
            console.log(checkIfSolvable(board))
        }
        const findNodeEmptySpace = (treeNode) => {
            let foundEmptySpaceIndex;
            treeNode.forEach((row, index) => {
                const indexFound = row.findIndex(num => num == 0)
                if (indexFound !== -1) {
                    foundEmptySpaceIndex = [indexFound, index]
                }
            })
            return foundEmptySpaceIndex;
        }
        const calculateBestNextTreeNode = (tree, gScore) => {


            let bestNodeScore = Infinity;
            let bestNode = null;
            tree.map(node => {
                let nodeParent = node.parent
                let totalGScore = 0
                while (nodeParent.treeNode !== null) {
                    totalGScore += nodeParent.gValue
                    nodeParent = nodeParent.parent
                }
                if (node.hValue + node.gValue + totalGScore < bestNodeScore && node !== null) {
                    bestNodeScore = node.hValue + node.gValue + totalGScore
                    bestNode = node
                }
            })

            return bestNode
        }

        //fillBoard(board)
        checkIfSolvable(board)
        board.map((row, index) => {
            row.map(num => {
                const numWrapper = document.createElement("SPAN")
                const listItemContent = document.createTextNode(num)
                numWrapper.appendChild(listItemContent)
                boardHTML.children[index].appendChild(numWrapper)
            })

        })


        let solutionFound = false;
        const main = () => {
            const start = board;
            const endBoard = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]


            gCounter++
            console.log("Iterations: " + gCounter)
            if(!solutionFound){
                if (nextNode == null) {
                    expandedNodes.push(start)
                    buildTreeBranch(start, { treeNode: null }).forEach(node => {
                        frontier.push(node)
                    })
                    nextNode = calculateBestNextTreeNode(frontier, gCounter)
                } else {
                    expandedNodes.push(nextNode)
                    const nodeIndex = frontier.indexOf(nextNode)
                    frontier.splice(nodeIndex, 1)
                    buildTreeBranch(nextNode.treeNode, nextNode).forEach(node => {
                        frontier.push(node)
                    })
                    nextNode = calculateBestNextTreeNode(frontier, gCounter)
                    renderNewBoard(nextNode)
                }
                if (JSON.stringify(nextNode.treeNode) === JSON.stringify(endBoard)) {
                    solutionFound = true;
                    console.log('done!')
                    renderNewBoard(nextNode)
                    clearInterval(renderInterval)
                }
            }
        }

        const renderNewBoard = () => {
            document.getElementById("boardPuzzle").remove()
            const ul = document.createElement("ul")
            ul.id = "boardPuzzle"
            document.getElementById('main').appendChild(ul)
            for (let i = 0; i < 3; i++) {
                ul.appendChild(document.createElement("li"))
            }
            nextNode.treeNode.map((row, index) => {
                row.map(num => {
                    const numWrapper = document.createElement("SPAN")
                    const listItemContent = document.createTextNode(num)
                    numWrapper.appendChild(listItemContent)
                    ul.children[index].appendChild(numWrapper)
                })
            })
        }

        
        const renderInterval = setInterval(main, 33);
    </script>
</body>

</html>