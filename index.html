<html>

<head>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div id="main">
        <div id="originalBoard">
            <p> Original generated board:</p>
            <ul id="originalBoardPuzzle">
                <li></li>
                <li></li>
                <li></li>
            </ul>
        </div>
        <div id="solvingBoard">
            <p> Solving board:</p>
            <ul id="boardPuzzle">
                <li></li>
                <li></li>
                <li></li>
            </ul>
        </div>
    </div>
    <div id="infos">
        <p id="expanded-nodes"></p>
        <p id="biggest-frontier"></p>
        <p id="path-size"></p>
        <p id="current-hscore"></p>
        <button id="pauseButton" onclick="pauseSolution()">PAUSE</button>
    </div>
    <script>
        const boardHTML = document.getElementById("originalBoardPuzzle")
        const goalBoardMap = {
            1: [0, 0],
            2: [0, 1],
            3: [0, 2],
            4: [1, 0],
            5: [1, 1],
            6: [1, 2],
            7: [2, 0],
            8: [2, 1],
            0: [2, 2]
        }

        let entries = [
            [[1, 2, 3], [4, 5, 6], [0, 7, 8]],
            [[5, 7, 2], [0, 4, 8], [1, 6, 3]],
            [[4, 1, 3], [7, 0, 8], [6, 2, 5]],
            [[7, 4, 2], [8, 1, 5], [6, 3, 0]],
            [[1, 0, 3], [5, 2, 4], [7, 6, 8]],
            [[1, 6, 2], [8, 3, 0], [4, 5, 7]],
            [[7, 2, 6], [5, 0, 4], [1, 3, 8]],
            [[7, 1, 2], [4, 8, 0], [5, 6, 3]],
            [[6, 1, 5], [2, 0, 3], [4, 7, 8]],
            [[4, 0, 6], [5, 1, 2], [7, 8, 3]],
            [[2, 5, 0], [1, 6, 7], [4, 8, 3]],
            [[0, 3, 5], [1, 8, 7], [4, 6, 2]],
            [[2, 5, 0], [4, 6, 3], [7, 1, 8]],
            [[1, 0, 7], [4, 3, 2], [8, 5, 6]],
            [[1, 4, 5], [7, 6, 2], [0, 8, 3]],
            [[1, 4, 2], [7, 5, 0], [8, 3, 6]],
            [[3, 4, 6], [7, 1, 0], [2, 5, 8]],
            [[2, 0, 6], [7, 4, 1], [5, 3, 8]],
            [[1, 5, 3], [4, 2, 8], [0, 7, 6]],
            [[2, 0, 3], [7, 4, 6], [8, 5, 1]],
            [[0, 7, 5], [2, 3, 1], [8, 4, 6]],
            [[7, 3, 5], [8, 0, 1], [4, 2, 6]],
            [[4, 2, 6], [3, 7, 1], [5, 0, 8]],
            [[5, 2, 3], [8, 1, 0], [4, 6, 7]],
            [[7, 1, 5], [3, 2, 6], [8, 0, 4]],
            [[0, 8, 5], [3, 1, 2], [4, 7, 6]],
            [[5, 3, 8], [4, 1, 0], [6, 2, 7]],
            [[0, 1, 6], [8, 3, 5], [4, 7, 2]],
            [[5, 8, 2], [1, 7, 3], [4, 6, 0]],
            [[3, 5, 6], [0, 7, 4], [2, 1, 8]]
        ]
        const board = entries[3]
        //const board = [[1, 8, 2],[0, 4, 3],[7, 6, 5]]
        //const board = [[], [], []]
        const tree = []
        let gCounter = 0;
        let nextNode = null;


        const expandedNodes = []
        const frontier = []

        const findMovementPossibilities = (spaceIndex) => {
            const pos = spaceIndex[0]
            const row = spaceIndex[1]

            switch (row) {
                case 0:
                    switch (pos) {
                        case 0:
                            return [null, [1, 0], null, [0, 1]]
                        case 1:
                            return [null, [1, 1], [0, 0], [0, 2]]
                        case 2:
                            return [null, [1, 2], [0, 1], null]

                    }
                case 1:
                    switch (pos) {
                        case 0:
                            return [[0, 0], [2, 0], null, [1, 1]]
                        case 1:
                            return [[0, 1], [2, 1], [1, 0], [1, 2]]
                        case 2:
                            return [[0, 2], [2, 2], [1, 1], null]

                    }
                case 2:
                    switch (pos) {
                        case 0:
                            return [[1, 0], null, null, [2, 1]]
                        case 1:
                            return [[1, 1], null, [2, 0], [2, 2]]
                        case 2:
                            return [[1, 2], null, [2, 1], null]
                    }
            }
        }
        const buildTreeBranch = (parentNode, parentNodeInfo) => {
            const emptySpaceIndex = findNodeEmptySpace(parentNode)
            const possibleMovements = findMovementPossibilities(emptySpaceIndex)
            const treeBranchList = possibleMovements.map(possibility => {
                if (possibility) {
                    const treeNode = JSON.parse(JSON.stringify(parentNode));
                    const temp = treeNode[possibility[0]][possibility[1]]
                    treeNode[possibility[0]][possibility[1]] = 0
                    treeNode[emptySpaceIndex[1]][emptySpaceIndex[0]] = temp
                    let hCounter = 0;
                    treeNode.map((row, rowIndex) => {
                        const isAtRightPlace = row.map((num, numIndex) => {
                            const goalCoordinates = goalBoardMap[num]
                            if (num == 0) return null
                            if (goalCoordinates[0] !== rowIndex || goalCoordinates[1] !== numIndex) {
                                return hCounter++
                            }
                        })
                    })

                    if (JSON.stringify(parentNodeInfo.treeNode) !== JSON.stringify(treeNode) && JSON.stringify(parentNode) !== JSON.stringify(treeNode)) {
                        return { treeNode, hValue: hCounter, gValue: parentNodeInfo.gValue + 1, parent: parentNodeInfo }
                    }
                }
            })
            return treeBranchList.filter(val => val !== undefined && val !== null)
        }

        let bestNode = null;

        const fillBoard = (board) => {
            const numbersList = [1, 2, 3, 4, 5, 6, 7, 8, 0]
            for (let i = 0; i < board.length; i++) {
                while (board[i].length < 3) {
                    const randomNumber = numbersList[Math.floor(Math.random() * 9)]
                    const alreadyHasNumberInRows = board.map(row => {
                        return row.includes(randomNumber)
                    })
                    if (!alreadyHasNumberInRows[0] && !alreadyHasNumberInRows[1] && !alreadyHasNumberInRows[2]) {
                        board[i].push(randomNumber)
                    }
                }
            }
        }
        const findNodeEmptySpace = (treeNode) => {
            let foundEmptySpaceIndex;
            treeNode.forEach((row, index) => {
                const indexFound = row.findIndex(num => num == 0)
                if (indexFound !== -1) {
                    foundEmptySpaceIndex = [indexFound, index]
                }
            })
            return foundEmptySpaceIndex;
        }
        const calculateBestNextTreeNode = (tree) => {
            let bestNodeScore = Infinity;

            tree.map(node => {
                const fValue = node.hValue + node.gValue
                if (fValue < bestNodeScore && node !== null && JSON.stringify(nextNode) !== JSON.stringify(node)) {
                    bestNodeScore = fValue
                    bestNode = node
                    console.log(bestNode)
                    console.log(node)
                }
            })

            return bestNode
        }
        const isSolvable = (start) => {
            let inversions = 0
            const range = Array.from(Array(9).keys())
            JSON.stringify(range)
            for (i in range) {
                const [x, y] = [Math.floor(i / 3), i % 3];
                for (j in Array.from({ length: 8 }, (_, index) => i + 1)) {
                    const [x2, y2] = [Math.floor(j / 3), j % 3];
                    if (start[x][y] > 0 && start[x2][y2] > 0 && start[x2][y2] < start[x][y]) {
                        inversions += 1
                    }
                }
            }

            return inversions % 2 == 0
        }
        //fillBoard(board)
        board.map((row, index) => {
            row.map(num => {
                const numWrapper = document.createElement("SPAN")
                const listItemContent = document.createTextNode(num)
                numWrapper.appendChild(listItemContent)
                boardHTML.children[index].appendChild(numWrapper)
            })

        })


        let solutionFound = false;
        let pause = false;
        const main = () => {
            const start = board;
            const endBoard = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
            console.log("Iterations: " + gCounter)
            if (!solutionFound && !pause) {
                gCounter++
                if (nextNode == null) {
                    expandedNodes.push({ treeNode: start, parent: null, gValue: 0, hValue: 0 })
                    buildTreeBranch(start, { treeNode: null, gValue: 0, hValue: 0 }).forEach(node => {
                        frontier.push(node)
                    })
                    nextNode = calculateBestNextTreeNode(frontier, gCounter)
                } else {
                    expandedNodes.push(nextNode)
                    const nodeIndex = frontier.indexOf(nextNode)
                    frontier.splice(nodeIndex, 1)
                    buildTreeBranch(nextNode.treeNode, nextNode).forEach(node => {
                        frontier.push(node)
                    })
                    nextNode = calculateBestNextTreeNode(frontier, gCounter)
                    renderNewBoard(nextNode)
                }
                if (nextNode.hValue == 0) {
                    solutionFound = true;
                    console.log('done!')
                    renderNewBoard(nextNode)
                    clearInterval(renderInterval)
                }
            }
        }

        const pauseSolution = () => {
            const pauseButtonHTML = document.getElementById("pauseButton")
            pause = !pause
            if (pause) {
                return pauseButtonHTML.innerHTML = "CONTINUE"
            }
            return pauseButtonHTML.innerHTML = "PAUSE"

        }

        const renderNewBoard = () => {
            const ul = document.createElement("ul")
            ul.id = "boardPuzzle"
            document.getElementById('solvingBoard').appendChild(ul)
            for (let i = 0; i < 3; i++) {
                ul.appendChild(document.createElement("li"))
            }
            nextNode.treeNode.map((row, index) => {
                row.map(num => {
                    const numWrapper = document.createElement("SPAN")
                    const listItemContent = document.createTextNode(num)
                    numWrapper.appendChild(listItemContent)
                    ul.children[index].appendChild(numWrapper)
                })
            })
            const expandedNodesHTML = document.getElementById("expanded-nodes")
            expandedNodesHTML.innerHTML = `Total expanded nodes: ${expandedNodes.length}`
            const biggestFrontierHTML = document.getElementById("biggest-frontier")
            biggestFrontierHTML.innerHTML = `Biggest frontier length: ${frontier.length}`
            const pathSizeHTML = document.getElementById("path-size")
            pathSizeHTML.innerHTML = `Current path size: ${nextNode.gValue}`
            const hScoreHTML = document.getElementById("current-hscore")
            hScoreHTML.innerHTML = `Current hScore: ${nextNode.hValue}`
            document.getElementById("boardPuzzle").remove()
        }

        const renderInterval = setInterval(main, 33);
        // if (!isSolvable(board)) {
        //     alert("Generated board is not resolvable. Please refresh page to try again!")
        // } else {

        // }
    </script>
</body>

</html>